import fnmatch as fm
import subprocess

import pandas as pd
from PyQt4 import uic

from wsm.config import *
from wsm.download import *
from wsm.models import *
from wsm.managers import *
from wsm.downloader.utils import time_human
import time

base, form = uic.loadUiType("acm/ui/mainWin.ui")


class AerodromeChartManager(base, form):

    def __init__(self, parent=None):
        super(AerodromeChartManager, self).__init__(parent)
        self.setupUi(self)
        self.setAttribute(Qt.WA_DeleteOnClose)

        # Test
        self.count = 0

        # Paths
        self.pjPath = None
        self.dlPath = None

        # Download Manager
        self.dl_mgr = None
        self.dl_thread = QThread()

        # Charts DataFrame
        self.charts_df = None

        # Lists
        self.clubNode_list = None
        self.countryNode_list = None
        self.icaoNode_list = None
        self.chartNode_list = None

        # Root Node
        self.rootNode = None
        # Tree Model
        self.treeModel = None
        self.sortFilterProxy_tree = None
        # Table Model
        self.tableModel = None
        self.sortFilterProxy_table = None

        # Refresh the tree
        self.refresh_icao_tree()

        # Initialize UI Elements
        self.uiProjectPath.setText(PROJECT_PATH)
        self.uiDownloadPath.setText(DOWNLOAD_PATH)

        # Initialize UI Signal Handlers
        self.init_uiEventHandlers()

    def refresh_icao_tree(self):

        # Root Node
        self.rootNode = Node('Charts')
        self.rootNode.set_data(['ICAO', 'Progress', 'Country', 'Filename', 'Description', 'Link'])

        # Tree Model
        self.treeModel = ChartTreeModel(self.rootNode)
        self.sortFilterProxy_tree = LeafFilterProxyModel()

        self.uiFilter.setText('')
        self.uiFilter.textChanged.connect(self.sortFilterProxy_tree.setFilterRegExp)

        self.clubNode_list = []
        self.countryNode_list = []
        self.icaoNode_list = []
        self.chartNode_list = []

        # Read the CSV files
        self.read_csv_lists(CSV_PATH)

        # Set model to tree view
        self.sortFilterProxy_tree.setSourceModel(self.treeModel)
        self.sortFilterProxy_tree.setDynamicSortFilter(True)
        self.sortFilterProxy_tree.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.uiTree.setModel(self.sortFilterProxy_tree)
        self.uiTree.sortByColumn(Qt.DescendingOrder)

        # Table Model
        self.tableModel = ChartTableModel()
        self.sortFilterProxy_table = TableSortFilterProxyModel()
        self.tableModel.setHeaders(self.rootNode.get_data())
        self.tableModel.setContents(self.treeModel.getChartNodes())

        # Set model to list view
        self.sortFilterProxy_table.setSourceModel(self.tableModel)
        self.sortFilterProxy_table.setDynamicSortFilter(True)
        self.uiTable.setItemDelegateForColumn(1, ProgressDelegate())
        self.uiTable.setModel(self.sortFilterProxy_table)
        # self.uiTable.resizeColumnsToContents()
        self.uiTable.horizontalHeader().setResizeMode(4, QHeaderView.Stretch)
        self.uiTable.horizontalHeader().setResizeMode(5, QHeaderView.Stretch)
        # self.uiTable.setColumnWidth(1, 200)

        # Initialize Custom Signal Handlers
        self.init_customSignals()

        # Initialize UI states
        self.uiSelectAll.setCheckState(Qt.Unchecked)
        self.uiDownload.setEnabled(True)

        # Handle the killing of any running download thread
        if self.dl_thread.isRunning():
            self.dl_thread.quit()

    def read_csv_lists(self, csvDir=None):
        # List all CSV files available
        csvList = os.listdir(csvDir)
        # Take only chart lists generated by the spiders (with suffix '__LinkList.csv')
        chartList_f = [f for f in csvList if fm.fnmatch(f, '*__LinkList.csv')]

        self.charts_df = pd.DataFrame()

        # Read each CSV files and append contents in a single dataframe
        for chart_f in chartList_f:

            chart_file = str(csvDir + chart_f)
            chartsList_df = pd.read_csv(chart_file, index_col=False, encoding='iso-8859-1', skipinitialspace=True)
            self.charts_df = self.charts_df.append(chartsList_df)

        # Create Chart Nodes
        for row in self.charts_df.itertuples():
            chart = self.create_chartNode(name=row.file, parent=None, data=[row.icao, 0, row.country, row.file, row.desc, row.link, row.club])
            # Append to list of chart nodes
            self.chartNode_list.append(chart)

        # Create Group Nodes
        self.clubNode_list.append(self.create_clubNode(name='Default'))
        self.clubNode_list.append(self.create_clubNode(name='EuroControl'))
        self.clubNode_list.append(self.create_clubNode(name='FBO'))
        self.clubNode_list.append(self.create_clubNode(name='Parking'))

        # Create Country Nodes
        country_list = self.charts_df.drop_duplicates(subset='country', keep='first')['country'].tolist()

        for country in country_list:
            self.countryNode_list.append(self.create_countryNode(country))
        # Create ICAO Nodes
        for chart in self.chartNode_list:
            d = chart.get_data()

            newIcaoNode = self.create_icaoNode(name=d[0], country=d[2])

            # Check if already in the ICAO Node list
            x = 0
            for i in self.icaoNode_list:
                if i.name() == newIcaoNode.name():
                    # Already in the list
                    x += 1

            if x == 0:
                # New ICAO Node not yet in the list
                self.icaoNode_list.append(newIcaoNode)

        # Setting the parents of each ICAO Nodes
        for i in self.icaoNode_list:
            for country in self.countryNode_list:
                i_country = i.get_data()[1]
                if i_country == country.name():
                    i.set_parent(country)

        # Setting the parents of each Chart Nodes
        for ch in self.chartNode_list:
            for i in self.icaoNode_list:
                ch_icao = ch.get_data()[0]
                if ch_icao == i.name():
                    ch.set_parent(i)

        # Setting the parents of each Country Nodes
        for country in self.countryNode_list:
            # print(country.name(), len(country.children()))
            icao = country.children()[0]
            club = icao.children()[0].get_data()[6]

            for c in self.clubNode_list:
                if c.name() == club:
                    country.set_parent(c)

    def create_clubNode(self, name):
        return ClubNode(name, parent=self.rootNode)

    def create_countryNode(self, name):
        return CountryNode(name, parent=None)

    def create_icaoNode(self, name, country):
        return IcaoNode(name, country, parent=None)

    def create_chartNode(self, name, parent, data):
        return ChartNode(name, parent, data)

    def init_uiEventHandlers(self):
        # Event Handlers (Signals/Slot)
        #     QtCore.QObject.connect(widget, QtCore.SIGNAL('signalname'), slot_function)
        #     widget.signal.connect(slot_function)
        self.uiBrowseProject.clicked.connect(self.browse_project_path)
        self.uiRefreshList.clicked.connect(self.refresh_icao_tree)
        self.uiSelectAll.stateChanged.connect(self.select_all)
        self.uiFilter.textChanged.connect(self.sortFilterProxy_tree.setFilterRegExp)
        self.uiBrowseDownload.clicked.connect(self.browse_download_path)
        self.uiDownload.clicked.connect(self.download_charts)
        self.uiManage.clicked.connect(self.manage_charts)

        # Drop Handler for Line Editors
        self.uiProjectPath.installEventFilter(LineEditDropHandler(self))
        self.uiDownloadPath.installEventFilter(LineEditDropHandler(self))

    def init_customSignals(self):
        self.treeModel.checkChanged.connect(self.update_chart_table)

    def update_chart_table(self):

        newContent = self.treeModel.getChartNodes()

        self.tableModel.clearRows()

        self.tableModel.setContents(newContent)

    def select_all(self):

        if self.uiSelectAll.isChecked():
            self.rootNode.set_checked(Qt.Checked)
        else:
            self.rootNode.set_checked(Qt.Unchecked)

        print(self.rootNode.checked())

        self.treeModel.layoutChanged.emit()
        self.treeModel.checkChanged.emit()

    def browse_project_path(self):

        self.uiProjectPath.clear()
        projDir = QFileDialog.getExistingDirectory(parent=self, caption='Pick Project Folder', directory=PROJECT_PATH)

        if projDir:
            self.uiProjectPath.setText(projDir)

    def browse_download_path(self):

        self.uiDownloadPath.clear()
        dlDir = QFileDialog.getExistingDirectory(parent=self, caption='Pick Download Folder', directory=DOWNLOAD_PATH)

        if dlDir:
            self.uiDownloadPath.setText(dlDir)

    def download_charts(self):
        print('Download Clicked!')

        dl_list = []

        # Extract information of the Download Items
        for idx, chart in enumerate(self.tableModel.getChartList()):
            icao = chart.data(0)
            country = chart.data(2)
            link = chart.data(5)
            filename = chart.data(3)
            pos = idx

            # Construct the download path
            if country == 'USA':
                dest = os.path.abspath(DOWNLOAD_PATH + country + '\\' + icao + '\\' + str(filename) + '.zip')
            else:
                dest = os.path.abspath(DOWNLOAD_PATH + country + '\\' + icao + '\\' + str(filename) + '.pdf')

            # Append to a list
            dl_list.append([link, dest, pos])

        self.dl_mgr = DownloadManager(dl_list)

        self.dl_thread.started.connect(self.dl_mgr.activate)
        self.dl_mgr.progress_ready.connect(self.update_progress)
        self.dl_mgr.moveToThread(self.dl_thread)
        self.dl_thread.start()

        self.uiDownload.setEnabled(False)

    def manage_charts(self):
        print('Manage Clicked!')

        mgr_USA = ChartManagerUSA()
        mgr_USA.manage()

    def update_progress(self, progress):

        prog, pos = progress
        self.tableModel.setProgress(prog, pos)

    def crawl_spiders(self):
        subprocess.call('activate python36', shell=True)
        subprocess.call('scrapy crawl Argentina --loglevel=WARNING', shell=True)

        self.refresh_icao_list()


class LineEditDropHandler(QObject):

    def __init__(self, parent=None):
        QObject.__init__(self, parent)

    def eventFilter(self, obj, event):
        if event.type() == QEvent.DragEnter:
            # we need to accept this event explicitly to be able to receive QDropEvents!
            event.accept()
        if event.type() == QEvent.Drop:
            md = event.mimeData()
            if md.hasUrls():
                for url in md.urls():
                    path = os.path.abspath(str(url.path()).lstrip('/'))
                    if os.path.isdir(path):
                        obj.setText(path)
                    break
            event.accept()
        return QObject.eventFilter(self, obj, event)

